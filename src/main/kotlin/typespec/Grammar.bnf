{
    parserClass="typespec._TsParser"
    psiClassPrefix="Ts"
    psiImplClassSuffix="Impl"
    psiPackage="typespec.psi.interfaces"
    psiImplPackage="typespec.psi.impl"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    elementTypeHolderClass="typespec.TsTypes"
    elementTypeClass="typespec.TsElementType"
    tokenTypeClass="typespec.TsTokenType"

    tokens=[
        WHITE_SPACE='regexp:[ \n\r\t\f]+'
        COMMENT='regexp:"//"[^\n]*'
        MULTILINE_COMMENT="regexp:/\*\*([^*]|\*+[^*/])*\*+/"

        PIPE='|'
        QUESTION='?'
        EQUALS='='
        AMPERSAND='&'
        COLON=':'
        COMMA=','
        SEMICOLON=';'
        DOT='.'
        LT='<'
        GT='>'
        LPAREN='('
        RPAREN=')'
        LBRACE='{'
        RBRACE='}'
        LBRACK='['
        RBRACK=']'
        DOUBLE_AT='@@'
        AT='@'
        ELLIPSIS='...'
        HASH='#'

        IMPORT="import"
        USING="using"
        NAMESPACE="namespace"
        SCALAR="scalar"
        MODEL="model"
        EXTENDS="extends"
        IS="is"
        INTERFACE="interface"
        INIT="init"
        OP="op"
        ENUM="enum"
        TYPEOF="typeof"
        EXTERN="extern"
        DEC="dec"
        FN="fn"
        ALIAS="alias"

        STRING_LITERAL1="regexp:'.*'"
        STRING_LITERAL2="regexp:`.*`"
        STRING_LITERAL3='regexp:\".*\"'
        STRING_LITERAL4="regexp:'''[^']*'''"
        STRING_LITERAL5="regexp:\"\"\"[^\"]*\"\"\""
        INT_LITERAL='regexp:-?\d+'
        FLOAT_LITERAL='regexp:-?\d+\.\d+'
        IDENTIFIER="regexp:[a-zA-Z_$]+\w*"
    ]
}

private typeSpecFile ::= TypeSpecScript

private TypeSpecScript ::=
        TypeSpecScriptItem*

private TypeSpecScriptItem ::=
        BlocklessNamespaceStatement
    |   ImportStatement
    |   Statement

private BlocklessNamespaceStatement ::=
        DecoratorList? NAMESPACE IdentifierOrMemberExpression SEMICOLON

private ImportStatement ::=
        IMPORT StringLiteral SEMICOLON

private StatementList ::=
        Statement+

private Statement ::=
        ModelStatement
    |   ScalarStatement
    |   InterfaceStatement
    |   NamespaceStatement
    |   OperationStatement
    |   UsingStatement
    |   EnumStatement
    |   AliasStatement
    |   AugmentDecoratorStatement
    |   DecoratorDeclarationStatement
    |   FunctionDeclarationStatement
    |   SEMICOLON

private UsingStatement ::=
        USING IdentifierOrMemberExpression SEMICOLON

private ModelStatement ::=
        DecoratorList? MODEL IdentifierVariable TemplateParameters? ModelHeritage? LBRACE ModelBody? RBRACE
    |   DecoratorList? MODEL IdentifierVariable TemplateParameters? IsModelHeritage SEMICOLON

private IsModelHeritage ::=
        IS Expression

private ScalarStatement ::=
        DecoratorList? SCALAR IdentifierVariable TemplateParameters? ScalarExtends? SEMICOLON
    |   DecoratorList? SCALAR IdentifierVariable TemplateParameters? ScalarExtends? LBRACE ScalarBody? RBRACE

private ScalarExtends ::=
        EXTENDS Expression

private ScalarBody ::=
        ScalarMemberList SEMICOLON?

private ScalarMemberList ::=
        ScalarMember (SEMICOLON ScalarMember)*

private ScalarMember::=
        INIT IdentifierVariable LPAREN FunctionParameterList? RPAREN

private ExtendsModelHeritage ::=
        EXTENDS Expression

private ModelHeritage ::=
        IsModelHeritage
    |   ExtendsModelHeritage
    
private ModelBody ::=
        ModelPropertyList (COMMA|SEMICOLON)?

private ModelPropertyList ::=
        ModelProperty ((COMMA|SEMICOLON) ModelProperty)*

private ModelProperty ::=
        ModelSpreadProperty
    |   DecoratorList? (IdentifierVariable|StringLiteral) QUESTION? COLON Expression (EQUALS Expression)?

private ModelSpreadProperty ::=
        ELLIPSIS ReferenceExpression

private InterfaceStatement ::=
        INTERFACE IdentifierVariable TemplateParameters? InterfaceHeritage? LBRACE InterfaceBody? RBRACE

private InterfaceHeritage ::=
        EXTENDS ReferenceExpressionList;

private InterfaceBody ::=
        InterfaceMemberList SEMICOLON?

private InterfaceMemberList ::=
        InterfaceMember (SEMICOLON InterfaceMember)*

private InterfaceMember ::=
        OP? IdentifierVariable OperationSignature

private EnumStatement ::=
        DecoratorList? ENUM IdentifierVariable LBRACE EnumBody? RBRACE

private EnumBody ::=
        EnumMemberList (COMMA|SEMICOLON)?

private EnumMemberList ::=
        EnumMember ((COMMA|SEMICOLON) EnumMember)*

private EnumMember ::=
        EnumSpreadMember
    |   DecoratorList? IdentifierVariable EnumMemberValue?
    |   DecoratorList? StringLiteral EnumMemberValue?

private EnumSpreadMember ::=
        ELLIPSIS ReferenceExpression

private EnumMemberValue ::=
        COLON StringLiteral
    |   COLON NumericLiteral

private AliasStatement ::=
        ALIAS IdentifierVariable TemplateParameters? EQUALS Expression;
    
private TemplateParameters ::=
        LT TemplateParameterList GT

private TemplateParameterList ::=
        TemplateParameter (COMMA TemplateParameter)*

private TemplateParameter ::=
        IdentifierVariable TemplateParameterConstraint? TemplateParameterDefault?

private TemplateParameterConstraint ::=
        EXTENDS MixedParameterConstraint

private MixedParameterConstraint ::=
//  UnionExpressionOrHigher[+InParameter]
        UnionExpressionOrHigher
    |   valueof UnionExpressionOrHigher

  
private TemplateParameterDefault ::=
        EQUALS Expression

private NamespaceStatement ::=
        DecoratorList? NAMESPACE IdentifierOrMemberExpression LBRACE StatementList? RBRACE

private OperationSignatureDeclaration ::=
        LPAREN (ModelPropertyList (COMMA|SEMICOLON)?)?  RPAREN COLON Expression

private OperationSignatureReference ::=
        IS ReferenceExpression

private OperationSignature ::=
        OperationSignatureDeclaration
    |   OperationSignatureReference

private OperationStatement ::=
        DecoratorList? OP IdentifierVariable TemplateParameters? OperationSignature SEMICOLON

private Expression ::=
        UnionExpressionOrHigher

private //UnionExpressionOrHigher[InParameter] ::=
//    IntersectionExpressionOrHigher[?InParameter]
//    PIPE? UnionExpressionOrHigher[?InParameter] PIPE IntersectionExpressionOrHigher[?InParameter]

private UnionExpressionOrHigher ::=
        IntersectionExpressionOrHigher (PIPE IntersectionExpressionOrHigher)*

private //IntersectionExpressionOrHigher[InParameter] ::=
//    ArrayExpressionOrHigher[?InParameter]
//    AMPERSEND? IntersectionExpressionOrHigher[?InParameter] AMPERSEND ArrayExpressionOrHigher[?InParameter]

private IntersectionExpressionOrHigher ::=
        ArrayExpressionOrHigher (AMPERSEND ArrayExpressionOrHigher)*
//    |   AMPERSEND? IntersectionExpressionOrHigher AMPERSEND ArrayExpressionOrHigher


private TypeOfExpression ::=
        TYPEOF Literal
    |   TYPEOF ReferenceExpression
    |   TYPEOF ParenthesizedExpression

private //ArrayExpressionOrHigher[InParameter] ::=
//    PrimaryExpression[?InParameter]
//    ArrayExpressionOrHigher[?InParameter] LBRACK RBRACK

private ArrayExpressionOrHigher ::=
        PrimaryExpression (LBRACK RBRACK)*

private //PrimaryExpression[InParameter] ::=
private PrimaryExpression ::=
        TypeOfExpression
    |   Literal
    |   CallOrReferenceExpression
//    ParenthesizedExpression[?InParameter]
    |   ParenthesizedExpression
    |   ObjectLiteral
    |   ArrayLiteral
    |   ModelExpression
    |   TupleExpression

private Literal ::=
        StringLiteral
    |   BooleanLiteral
    |   NumericLiteral

private CallOrReferenceExpression ::=
        CallExpression
    |   ReferenceExpression
//CallExpression
//    IdentifierOrMemberExpression CallArguments

private ReferenceExpression ::=
        IdentifierOrMemberExpression TemplateArguments?

private ReferenceExpressionList ::=
        ReferenceExpression (COMMA ReferenceExpression)*

private IdentifierOrMemberExpression ::=
        IdentifierVariable (DOT IdentifierVariable)*

private TemplateArguments ::=
        LT ExpressionList GT

private //ParenthesizedExpression[InParameter] ::=
//    [~InParameter] LPAREN Expression RPAREN
//    [+InParameter] LPAREN MixedParameterConstraint RPAREN
private ParenthesizedExpression ::=
        LPAREN Expression RPAREN
    |   LPAREN MixedParameterConstraint RPAREN

private ObjectLiteral ::=
        '#{' ObjectLiteralBody? RBRACE

private ObjectLiteralBody ::=
        ModelPropertyList COMMA?

private ArrayLiteral ::=
        '#[' ExpressionList? RBRACK

private ModelExpression ::=
        LBRACE ModelBody? RBRACE

private TupleExpression ::=
        LBRACK ExpressionList? RBRACK

private ExpressionList ::=
        Expression (COMMA Expression)*

DecoratorList ::=
        Decorator+

Decorator ::=
        AT IdentifierOrMemberExpression DecoratorArguments?

private DecoratorArguments ::=
        LPAREN ExpressionList? RPAREN

private CallExpression ::=
        IdentifierOrMemberExpression LPAREN ExpressionList? RPAREN

private AugmentDecoratorStatement ::=
        DOUBLE_AT IdentifierOrMemberExpression DecoratorArguments?

private //AugmentDecoratorArguments ::=
//  LPAREN ExpressionList RPAREN

private DecoratorDeclarationStatement ::=
        DecoratorModifiers? DEC LPAREN FunctionParameterList? RPAREN

private DecoratorModifiers::=
        EXTERN

private FunctionDeclarationStatement ::=
        FunctionModifiers? FN LPAREN FunctionParameterList? RPAREN TypeAnnotation?

private TypeAnnotation ::=
        COLON MixedParameterConstraint

private FunctionModifiers ::=
        EXTERN

private FunctionParameterList ::=
        FunctionParameter (COMMA FunctionParameter)*

private FunctionParameter ::=
        ELLIPSIS? IdentifierVariable QUESTION? TypeAnnotation?

IdentifierVariable ::=
        IDENTIFIER

private StringLiteral ::=
        STRING_LITERAL1
    |   STRING_LITERAL2
    |   STRING_LITERAL3
    |   STRING_LITERAL4
    |   STRING_LITERAL5

private NumericLiteral ::=
        INT_LITERAL
    |   FLOAT_LITERAL

private BooleanLiteral ::=
        BOOL_LITERAL